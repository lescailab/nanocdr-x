{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nanocdr-x","text":"<p>Predict and explain CDR regions in nanobody sequences.</p> <p>A lightweight CLI package that:</p> <ul> <li>predict_cdrs: infers CDR1/2/3 regions from input FASTA\u2011style CSV.  </li> <li>explain_hidden_states: extracts per\u2011token BiLSTM hidden states.  </li> <li>explain_saliency: computes gradient\u2011based saliency maps.</li> </ul> <p>Learn more in the Usage guide or dive into the API Reference.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#usage","title":"Usage","text":""},{"location":"usage/#installation","title":"Installation","text":"<pre><code>conda install -c lescailab nanocdr-x\n</code></pre>"},{"location":"usage/#commands","title":"Commands","text":""},{"location":"usage/#predict_cdrs","title":"predict_cdrs","text":"<pre><code>predict_cdrs \\\n  -i path/to/input.csv \\\n  -o path/to/output_cdrs.csv\n</code></pre> <ul> <li><code>-i/--input</code>: CSV with columns identifier,input.</li> <li><code>-o/--output</code>: Path to write identifier,predicted_cdr1,predicted_cdr2,predicted_cdr3.</li> </ul>"},{"location":"usage/#explain_hidden_states","title":"explain_hidden_states","text":"<pre><code>explain_hidden_states \\\n  -i path/to/input.csv \\\n  -o path/to/hidden_states.csv\n</code></pre> <p>Outputs a table with one row per non\u2011pad token, including:</p> <ul> <li>sequence_id</li> <li>position</li> <li>token</li> <li>pred_class</li> <li>hs_dim_0\u2026hs_dim_N</li> </ul>"},{"location":"usage/#explain_saliency","title":"explain_saliency","text":"<pre><code>explain_saliency \\\n  -i path/to/input.csv \\\n  -o path/to/saliency.csv\n</code></pre> <p>Outputs a detailed saliency map with columns:</p> <ul> <li>sequence_id</li> <li>time_point</li> <li>position</li> <li>predicted_class</li> <li>saliency</li> </ul>"},{"location":"api_reference/explain_hidden_states/","title":"explain_hidden_states CLI","text":""},{"location":"api_reference/explain_hidden_states/#description","title":"Description","text":"<p>This script reads the same input CSV, pads and tokenizes sequences, then extracts the hidden\u2010state activations from the second bidirectional LSTM layer for every non\u2010padded token. It produces a long\u2010form CSV where each row corresponds to one token in one sequence, annotated with:</p> <ul> <li>sequence_id  </li> <li>position (time step)  </li> <li>token  </li> <li>predicted class  </li> <li>hs_dim_0 \u2026 hs_dim_{H-1} (one column per hidden dimension)</li> </ul>"},{"location":"api_reference/explain_hidden_states/#theoretical-background","title":"Theoretical background","text":"<ul> <li>In RNNs (including LSTM), hidden states are the internal memory at each time step, capturing context from past inputs.  </li> <li>A bidirectional LSTM maintains two hidden vectors per time step (forward + backward). Here we extract the concatenated output of the last LSTM layer.  </li> <li>To retrieve hidden states, we re\u2010construct a sub\u2010model in Keras: define a new <code>Model(inputs=original_input, outputs=second_LSTM_output)</code> so calling <code>predict()</code> yields hidden activations instead of final classifications.  </li> <li>These hidden vectors can be used for down\u2010stream interpretability, clustering, visualization, or as features in other predictive models.</li> </ul>"},{"location":"api_reference/explain_hidden_states/#usage","title":"Usage","text":"<pre><code>  explain_hidden_states \\\n    -i /path/to/input.csv \\\n    -o /path/to/hidden_states.csv \\\n    [--model /path/to/model_dir] \\\n    [--char_mapping /path/to/char_mapping.csv]\n</code></pre>"},{"location":"api_reference/explain_hidden_states/#options","title":"Options","text":"<pre><code>  -i, --input         path to CSV with 'identifier' and 'input' columns  \n  -o, --output        path where hidden\u2010states CSV will be saved  \n  --model             optional override of the model directory  \n  --char_mapping      optional override of the char\u2192int mapping CSV  \n</code></pre>"},{"location":"api_reference/explain_saliency/","title":"explain_saliency CLI","text":""},{"location":"api_reference/explain_saliency/#description","title":"Description","text":"<p>This script computes gradient\u2010based saliency maps for each non\u2010padded token in each sequence. For each target time point t, it records how sensitive the model\u2019s predicted class probability is to each input position p, yielding a 2D saliency matrix. The output CSV has one row per (sequence, time_point, position) triple with:</p> <ul> <li>sequence_id  </li> <li>time_point (target step)  </li> <li>position (input step)  </li> <li>predicted_class at time_point  </li> <li>saliency value (gradient magnitude)</li> </ul>"},{"location":"api_reference/explain_saliency/#theoretical-background","title":"Theoretical background","text":"<ul> <li>Saliency maps in deep learning measure the gradient of an output scalar (e.g., class probability) with respect to input features or embeddings.  </li> <li>TensorFlow\u2019s GradientTape API records operations on tensors; by watching the embedding output and computing <code>tape.gradient(prob, embedding)</code>, one obtains how much each embedding dimension influences the probability.  </li> <li>Aggregating (e.g., mean absolute value) across embedding dimensions yields a single saliency score per position.  </li> <li>Saliency across (t,p) reveals which input residues are most influential for each predicted residue label.</li> </ul>"},{"location":"api_reference/explain_saliency/#usage","title":"Usage","text":"<pre><code>  explain_saliency \\\n    -i /path/to/input.csv \\\n    -o /path/to/saliency.csv \\\n    [--model /path/to/model_dir] \\\n    [--char_mapping /path/to/char_mapping.csv]\n</code></pre>"},{"location":"api_reference/explain_saliency/#options","title":"Options","text":"<pre><code>  -i, --input         path to CSV with 'identifier' and 'input' columns  \n  -o, --output        path where saliency CSV will be saved  \n  --model             optional override of the model directory  \n  --char_mapping      optional override of the char\u2192int mapping CSV  \n</code></pre>"},{"location":"api_reference/predict_nanobody_cdrs/","title":"predict_cdrs CLI","text":""},{"location":"api_reference/predict_nanobody_cdrs/#description","title":"Description:","text":"<p>This script takes an input CSV with columns 'identifier' and 'input' (amino-acid sequences), pads each sequence to a fixed length (150) using the 'Z' character, tokenizes each character via a pre\u2010built mapping, and runs the sequences through a trained TensorFlow LSTM model. The model outputs per\u2010position class predictions, which are then trimmed of padding and used to extract the three complementarity\u2010determining region (CDR) segments (CDR1, CDR2, CDR3) via simple substring extraction functions. Results are saved to an output CSV.</p>"},{"location":"api_reference/predict_nanobody_cdrs/#theoretical-background","title":"Theoretical background:","text":"<ul> <li>CDRs are the hypervariable loops in antibody/nanobody sequences that determine binding specificity.  </li> <li>The model architecture: an Embedding layer \u2192 two bidirectional LSTM layers \u2192 TimeDistributed Dense for per\u2010position classification.  </li> <li>Padding to a fixed length ensures uniform input shape; predictions beyond the real sequence (padded) are discarded via trimming.  </li> <li>Output classes correspond to integer labels that denote CDR membership or non\u2010CDR.  </li> </ul>"},{"location":"api_reference/predict_nanobody_cdrs/#usage","title":"Usage:","text":"<pre><code>  predict_cdrs \\\n    -i /path/to/input.csv \\\n    -o /path/to/output_cdrs.csv \\\n    [--model /path/to/model_dir] \\\n    [--char_mapping /path/to/char_mapping.csv]\n</code></pre>"},{"location":"api_reference/predict_nanobody_cdrs/#options","title":"Options:","text":"<pre><code>  -i, --input         path to CSV with 'identifier' and 'input' columns  \n  -o, --output        path where output CSV with predicted CDR columns will be saved  \n  --model             optional override of the model directory (default from package)  \n  --char_mapping      optional override of the char\u2192int mapping CSV (default from package)\n</code></pre>"}]}